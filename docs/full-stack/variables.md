Go 语言属于静态编译型语言，也就意味着，在 Go 语言中，<u>使用变量之前需要先进行变量申明</u>。

## Go 语言中的变量

在 Go 中要做好变量声明的一致性，需要明确下面几点：

- 全局变量 or 局部变量
- 是否要延迟初始化
- 是否接受默认类型
- 是否为分支控制变量
- 位置遵循声明聚类与就近原则

Go 语言中变量可以分为两类：

- **局部变量**：函数或方法体内声明的变量，另外函数定义中的变量称为形式参数会作为函数的局部变量来使用。
- **全局变量**：函数或方法体外声明的变量，也称为包级变量

### 声明聚类与就近原则

变量声明位置主要遵循两个原则：<u>声明聚类与就近原则。</u>

#### 声明聚类

声明聚类主要有两种情况：

- 1.将同一类的变量声明放在一个 var 块，将不同类的变量声明放在不同的 var 块中
- 2.将延迟初始化的变量声明放在一个 var 块，将声明时就显式进行初始化的变量声明放在另一个 var 块中

#### 就近原则

> Q：是否应当将全局变量声明全部集中放在源文件头部？

就近原则，即尽可能在靠近第一次使用的位置声明变量。就近原则实际上是变量的作用域最小化的一种实现手段。

- 如果该全局变量会在包内部多处使用，则尽量集中放在源文件头部
- 如果该全局变量在包内部只使用一次，就直接就近安排在使用变量的位置进行声明

### 全局变量的声明形式

```go
// 1.声明时采用默认类型（Go编译器会自动根据表达式右边的值设置变量类型）
var a = 10  // 默认设置类型为int
var b = 3.1  // 默认设置类型为float64

// 声明时指定类型，有两种方式：
var a int32 = 10
var a = int32(10)    // 更推荐这种，能够跟采用默认类型时的声明形式统一

// 声明时延迟初始化
var a int32

// 多个变量声明
var (
  a = 10
  b = 11
)
var a,b = 10,"11"
```

### 局部变量的声明形式

局部变量比全局变量多了一种声明形式：<u>短变量声明形式</u>。这也就是说，短变量重声明只能在局部代码块作用域里。

```go
a := 10
a,b := 10,"11"

for _,b := range *v {
  nb,err := w.Write(b)
}

```

## Go 语言中的常量

Go 语言中有两种常量：

- 无类型常量
- 有类型常量

```go
// 无类型常量
const a = 5

// 有类型常量
const a int = 5
```

### 有类型常量

Go 不支持隐式型转换。

```go
type myInt int
const n myInt = 1
const m int = n + 5    // 编译器报错
const m int = int(n) + 5    // 进行显示类型转换后正常工作
```

### 无类型常量 🎃

当把无类型常量赋值给一个变量时，无类型常量会被隐式的转化成对应的类型。

```go
const a = 1
var b int16 = a
var c int32 = a
fmt.Printf("type: %T \n", a) //type: int
fmt.Printf("type: %T \n", b) //type: int16
fmt.Printf("type: %T \n", c) //type: int32
```

> 无类型常量的优势：在混合数据类型运算时无需再做显示类型转化，代码更简洁

无类型常量拥有自己的默认类型，比如：

- 无类型的布尔值常量：true 和 false，默认类型为 bool
- 整数常量，默认类型为 int
- 字符常量，默认类型为 int32(rune)
- 浮点数常量，默认类型为 float64
- 复数常量，默认类型为 complex128
- 字符串常量，默认类型为 string

> 注：所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。

### 使用 iota 枚举常量

Go 中对于 const 语法提供了<u>“隐式重复前一个非空表达式”</u>的机制：

```go
const (
  a,b = 1,2
  c,d        // 被隐式使用第一行表达式，相当于 c,d = 1,2
  e,f        // 同样被赋值为 e,f = 1,2
)
```

此外，还可以用 iota 预定义标识符。

> iota 表示的是 const 声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。每一行中的 iota 都是无类型常量。

iota 特点：

- 代表偏移值，类似 index
- 隐式重复前一个非空表达式

```go
// 1.中间有插队
const (
  a = iota    // 0
  b = 100
  c = iota    // 2
)

// 2.略过iota
const (
  _ = iota
  a    // 1
  b    // 2
  _
  c    // 4
)
// 3.一行声明多个变量
const (
  a,b = iota+1, iota+2   // a=1,b=2
  c,d = iota+1, iota+2   // a=2,b=3
)
// 4.枚举有类型常量
type Weekday int
const (
  Sunday Weekday = iota
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
)
```

## 零值可用

Go 语言中的每个原生类型都有默认值，这个默认值就是这个类型的零值。

- 所有整型类型：0
- 浮点类型：0.0
- 布尔类型：false
- 字符串类型：""
- 指针、interface、切片（slice）、channel、map、function：nil

另外，Go 的零值初识是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。

#### append 场景下，零值可用的切片类型不能通过下标形式操作数据：

```go
var s []int
s[0] = 12       // error
s = append(s, 12)   // 正确
```

#### map 这样的原声类型也没有提供零值可用的支持：

```go
var m map[string]int
m["go"] = 1 //error

var n = make(map[string]int)
n["go"] = 1  // 正确
```

#### 零值可用的类型要注意尽量避免值复制：

```go
var mu sync.Mutex
mu1 := mu   // error
foo(mu)   // error
```
