## TCP/IP 分层模型

依据网络层次模型（ TCP/IP 五层划分模式）来说明所传输数据的封装与解封装过程：

![](./img/5tcp.png)

- 1.应用层-在应用层产生所要传输的数据，用 data 来表示（data）
- 2.传输层-常见的是 TCP、UDP 协议，两者都是基于端口的协议，端口的作用就是在主机上进程的唯一标识，所以这一层会被包裹上目标端口+源端口（目标端口+源端口+data）
- 3.网络层-一般来说主机都是处于不同的网络里，所以需要 ip 协议来确定目标主机所在的网络，因此数据在这一层会被包裹上目标主机的 ip 地址与当前主机的源 IP（目标 IP+源 IP+目标端口+源端口+data）（此时能够确定某一个网络，并不能在这个网络里哪一台机器是我们想要的）
- 4.数据链路层-通过 mac 地址完成寻址操作，所以数据会被包裹上目标主机与当前主机的 mac 地址（目标 mac+源 mac+目标 IP+源 IP+目标端口+源端口+data）（此时一条数据就被完整封装了）
- 5.物理层-网线无法识别二进制，所以经过网卡的调制之后就会变成高低电压，此时封装的数据就会转换成二进制形式，再经过路由器的网络分配和传输介质的运输，最终就会到达目标主机的网卡
- 6.物理层-进行数据解调，将电压变为二进制，再向上传递至链路层。
- 7.数据链路层-分析目标 mac 地址是否是当前主机的 mac 地址，如果是就拆解数据并继续向上层传递
- 8.网络层-分析目标 ip 是否是自己的 ip，如果是就拆解数据并继续向上层传递
- 9.传输层-分析目标端口是否是自己，如果是就拆解数据并继续向上层传递
- 10.数据层-此时主机 B 就拿到了主机 A 传过来的数据 data 了

## UDP 与 TCP 的区别

- UDP->面向无连接，TCP->面向有连接（需要在通信之前建立连接）
- TCP 可进行丢包时的重发控制，并对此虚乱掉的分包进行顺序控制，UDP 不可
- UDP 可随时发送数据，常用于即时通信、广播等

## 三次握手与四次挥手

为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传达后的情况置之不理，它一定会向对方确认是否成功送达。
握手过程中使用了 TCP 的标志（flag）—— `SYN（synchronize）`和 `ACK（acknowledgement）`。

:::success{title=三次握手与四次挥手涉及到的标志}

- SYN：表示请求建立连接
- FIN：表示断开链接
- ACK：表示信息确认
  :::

发送端首先发送一个带 `SYN` 标志的数据包给对方。接收端收到后，回传一个带有 `SYN/ACK` 标志（应该是先发送 ACK 标志的包再发送 SYN 标志的包，但一般情况下两个请求合并进行）的数据包以示传达确认信息。最后，发送端再回传一个带 `ACK` 标志的数据包，代表“握手”结束。

![](./img/tcp-connect1.png)

### Q1：为什么是三次握手，而不是两次/四次握手？

两次握手无法保证消息确认送达，ACK 与 SYN 可以合并以减少一次请求。

### Q2：如何避免历史连接？

在网络拥塞下，旧的 SYN 先到达 server，server 回应 SYN+ACK，client 根据上下文判定是否是历史连接，如果是则回应断开连接。

### Q3：四次挥手为何不能合并为三次？

保证服务端对上一次未处理完成的数据响应处理完。

## 持久连接与管线化

| 版本    | 主要技术                               | 是否默认开启             | 并发                         | 解决的问题                                                                                                                                                    | 描述                                                                       | 图例                                |
| ------- | -------------------------------------- | ------------------------ | ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ----------------------------------- |
| HTTP1.0 | -                                      |                          | -                            | -                                                                                                                                                             | -                                                                          | ![](./img/tcp-connect1.png)         |
| HTTP1.1 | <Badge type="warning">持久连接</Badge> | 默认开启                 |                              | 每进行一次 HTTP 通信都需要建立一次 TCP 连接                                                                                                                   | 任意一端未提出断开连接则保持 TCP 连接                                      | ![](./img/tcp-connect-long.png)     |
| http1.1 | <Badge type="warning">管线化</Badge>   | 默认不开启，需服务端支持 | 并发数量有限，比如 chrome->6 | 发送请求之后要等待，直到接收到响应才能发起在一个请求                                                                                                          | 在持久连接基础上实现了管线化机制，即可同时并行发送多个请求，不需要等待响应 | ![](./img/tcp-connect-pipeline.png) |
| http2.0 | <Badge type="warning">多路复用</Badge> | -                        | 不需要考虑并发请求量         | 持久连接模式下，多个 http 请求放在一个 TCP 连接里，其响应顺序按请求顺序来的，如果有一个请求出现阻塞，后面的就需要等待，即<Badge type="error">线头阻塞</Badge> | 多个请求复用一个 TCP 连接，TCP 连接分若干流，且互不影响，不需按顺序响应。  | -                                   |

## HTTP 各版本

HTTP/1.0 和 HTTP/1.1 支持的方法：
![](./img/http-methods.png)

- HTTP1.1
  - 增加了持久连接、管线化
  - 增加了 OPTIONS、TRACE、CONNECT 三种请求方法，废除了 LINK、UNLINK 两种方法
- HTTP2
  - 多路复用
  - push cache

## HTTPS

通常 HTTP 直接与 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信。简言之，HTTPS 是身披 SSL 协议外壳的 HTTP。

![](./img/ssl.png)

### HTTPS 的加密方式

- 对称加密：易泄漏
- 非对称加密：易篡改被冒充，效率低

HTTPS 采用<u>混合加密方式（对称加密+非对称加密）</u>，即非对称加密方式交换共享密钥，以对称加密方式进行通信。

### Q:为什么不一直使用 HTTPS？

## 申请证书的过程
