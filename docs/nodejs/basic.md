# NodeJs

刚接触 Node 的开发者可能会认为 NodeJs 就是 javaScript，但其实，<u>Nodejs 是 javascript（严格来说是 ECMAScript）运行时（runtime）</u>。Nodejs 底层使用 C++实现，语法则是遵循 ECMAScript 规范。

其中，runtime 可以理解为一种编程语言的运行环境，比如最出名的 runtime 是 VC++，它可以使 C/C++语言程序在其中运行。Chrome 也是一个 Javascript 运行时，其靠 JavaScript 引擎来运行 JavaScript 代码。

## 内部机制

### 异步过程中的回调

> 单线程运行的语言，在设计时需要解决一个问题：如果遇到一个耗时的操作，例如磁盘 IO，是否需要等待操作完成了再执行下一步操作？

PHP 选择了在完成之前继续等待，而 Node 选择了采用<u> `回调+回调`的方式实现对高并发的支持</u>。（遇到 IO 操作时，继续向下执行，等到 IO 操作完成之后，再执行对应的回调函数（异步））。

```js
var fs = require('fs');
var callback = function (err, data) {
  if (err) return;
  console.log(data);
};
fs.readFile('foo.text', callback);
```

### 同步/异步

针对这个概念，首先要明确<u>同步和异步描述的是进程/线程的调用方式</u>。

**同步调用**指进程/线程发起调用之后，要等到调用返回之后才继续执行下一步，但这并不意味着等待期间 CPU 也会一直等待，操作系统多半会切换到另一个进程/线程上去，等到调用返回之后再切换回去。

**异步调用**则相反，发起调用之后，会继续执行下一步，当调用返回后，通过某种手段来通知调用者。

我们常说 JavaScript 可以实现异步，但其实 ECMAScript 并没有异步的规范，JavaScript 的异步更多是依靠浏览器 runtime 内部其他线程来实现，并非 JavaScript 本身的功能，是浏览器提供的支撑让 JavaScript 看起来像是一个异步的语言。

### 阻塞/非阻塞

针对这个概念，首先要明确<u>阻塞/非阻塞是针对 IO 状态而言的</u>，关注程序在等待 IO 调用返回期间的状态。（Nodejs 中也没有异步的概念，而是选择了使用非阻塞这样的词汇代替）

输入/输出（I/O）是在内存和外部设备（如磁盘、终端和网络）之间复制数据的过程。

> ⚠️ 注意：阻塞=同步？非阻塞=异步？这是不正确的，在 IO 编程模型中，除了纯粹的 AIO 外，阻塞和非阻塞都是异步的。用一句话概括四者的关系：<u>同步调用会造成调用进程的 IO 阻塞，异步调用不会造成调用进程的 IO 阻塞。</u>

### 单线程/多线程

Nodejs 并没有提供多线程的支持，意味着开发者的代码只能运行在当前线程中，用于运行代码的事件循环也是单线程运行。

但在另一方面，Nodejs 底层实现却有多线程的存在，libuv 会通过类似**线程池**的实现来模拟不同操作系统的异步调用，但这对开发者不可见。所以，Nodejs 的异步调用时由 libuz 实现的，以 readFile 为例，读取文件的系统调用由 libuz 完成，Node 只负责调用 libuz 接口，等数据返回后再执行对应的回调方法。

### 并行/并发

举个例子来解释下两个词：

- 并发：两队人排队取票，但只有一个取票机，于是先有队列一排头的人上前取票，再由队列二的一个人上前取票，两个对列交叉上前取票，宏观来看都在以相同速度取票。
- 并行：两队人排队取票，安排了两个取票机，排队速度是并发方式的两倍。

Nodejs 中，也支持高并发，是依靠异步+事件驱动（循环）来实现的，异步使得代码在面临多个请求时不发生阻塞，事件循环提供了 IO 调用结束后调用回调函数的能力。

## 事件循环（Event Loop）
